InstructionSet XCoreVSIMD extends RISCVBase {
instructions {
    CV_SUBINCACC {
      encoding: 7'b0101000 :: rs2[4:0] :: rs1[4:0] :: 3'b011 :: rd[4:0] :: 7'b0101011;
      assembly: "{name(rd)}, {name(rs1)}, {name(rs2)}";
      behavior: {
        if (rd != 0) {
          X[rd] += X[rs1] - X[rs2] + 1;
        }
      }
    }
    CV_MAXU {
      encoding: 7'b0101110 :: rs2[4:0] :: rs1[4:0] :: 3'b011 :: rd[4:0] :: 7'b0101011;
      assembly: "{name(rd)}, {name(rs1)}, {name(rs2)}";
      behavior: {
        if (rd != 0) {
          X[rd] = X[rs1] > X[rs2] ? X[rs1] : X[rs2];
        }
      }
    }
    NAND {
      encoding: 7'b0101110 :: rs2[4:0] :: rs1[4:0] :: 3'b011 :: rd[4:0] :: 7'b1101011;
      assembly: "{name(rd)}, {name(rs1)}, {name(rs2)}";
      behavior: {
        if (rd != 0) {
          X[rd] = ~(X[rs1] & X[rs2]);
        }
      }
    }
    LB {
        encoding: imm[11:0] :: rs1[4:0] :: 3'b000 :: rd[4:0] :: 7'b0000011;
        assembly:"{name(rd)}, {imm}({name(rs1)})";
        behavior: {
            unsigned<32> load_address = X[rs1] + (signed)imm;
            signed<8> res = (signed<8>)MEM8[load_address];
            if((rd) != 0) X[rd] = (unsigned<32>)res;
        }
    }

    LH {
        encoding: imm[11:0] :: rs1[4:0] :: 3'b001 :: rd[4:0] :: 7'b0000011;
        assembly:"{name(rd)}, {imm}({name(rs1)})";
        behavior: {
            unsigned<32> load_address = X[rs1] + (signed)imm;
            signed<16> res = (signed<16>)MEM16[load_address];
            if ((rd) != 0) X[rd] = (unsigned<32>)res;
         }
    }

    LW {
        encoding: imm[11:0] :: rs1[4:0] :: 3'b010 :: rd[4:0] :: 7'b0000011;
        assembly:"{name(rd)}, {imm}({name(rs1)})";
        behavior: {
            unsigned<32> load_address = X[rs1] + (signed)imm;
            signed<32> res = (signed<32>)MEM32[load_address];
            if ((rd) != 0) X[rd] = (unsigned<32>)res;
        }
    }

    LBU {
            encoding: imm[11:0] :: rs1[4:0] :: 3'b100 :: rd[4:0] :: 7'b0000011;
            assembly:"{name(rd)}, {imm}({name(rs1)})";
            behavior: {
                unsigned<32> load_address = X[rs1] + (signed)imm;
                unsigned<8> res = (unsigned<8>)MEM8[load_address];
                if ((rd) != 0) X[rd] = (unsigned<32>)res;
            }
        }

    LHU {
        encoding: imm[11:0] :: rs1[4:0] :: 3'b101 :: rd[4:0] :: 7'b0000011;
        assembly:"{name(rd)}, {imm}({name(rs1)})";
        behavior: {
            unsigned<32> load_address = X[rs1] + (signed)imm;
            unsigned<16> res = (unsigned<16>)MEM16[load_address];
            if((rd) != 0) X[rd] = (unsigned<32>)res;
        }
    }
    // SB {
    //     encoding: imm[11:5] :: rs2[4:0] :: rs1[4:0] :: 3'b000 :: imm[4:0] :: 7'b0100011;
    //     assembly:"{name(rs2)}, {imm}({name(rs1)})";
    //     behavior: {
    //         unsigned<32> store_address = X[rs1] + (signed)imm;
    //         MEM8[store_address] = (signed<8>)X[rs2];
    //     }
    // }

    // SH {
    //     encoding: imm[11:5] :: rs2[4:0] :: rs1[4:0] :: 3'b001 :: imm[4:0] :: 7'b0100011;
    //     assembly:"{name(rs2)}, {imm}({name(rs1)})";
    //     behavior: {
    //         unsigned<32> store_address = X[rs1] + (signed)imm;
    //         MEM16[store_address] = (signed<16>)X[rs2];
    //     }
    // }

    // SW {
    //     encoding: imm[11:5] :: rs2[4:0] :: rs1[4:0] :: 3'b010 :: imm[4:0] :: 7'b0100011;
    //     assembly:"{name(rs2)}, {imm}({name(rs1)})";
    //     behavior: {
    //         unsigned<32> store_address = X[rs1] + (signed)imm;
    //         MEM32[store_address] = (signed<32>)X[rs2];
    //     }
    // }
    CV_LB_ri_inc {
        encoding: imm12[11:0] :: rs1[4:0] :: 3'b000 :: rd[4:0] :: 7'b0001011;
        // assembly: {"cv.lb", "{name(rd)}, {imm12}({name(rs1)}!)"};
        assembly: "{name(rd)}, {imm12}({name(rs1)}!)";
        behavior: {
            unsigned<32> load_address = X[rs1];
            signed<8> res = (signed<8>)MEM8[load_address];
            if (rd != 0) X[rd] = (unsigned<32>)res;
            X[rs1] += (signed)imm12;
        }
    }
  }

}
