// RUN: pattern-gen %s -O 3 --mattr=+m --riscv-xlen 64 | FileCheck --check-prefixes=CHECK-RV64,CHECK-RV64-EXTEND -allow-unused-prefixes %s
// RUN: pattern-gen %s -O 3 --no-extend --mattr=+m --riscv-xlen 64 | FileCheck --check-prefixes=CHECK-RV64,CHECK-RV64-NOEXTED -allow-unused-prefixes %s

InstructionSet XExampleRV64 extends RISCVBase {

    instructions {

      // ADDW { // does not work implicitly
      //     encoding: 7'b0000000 :: rs2[4:0] :: rs1[4:0] :: 3'b000 :: rd[4:0] :: 7'b0111011;
      //     assembly: "{name(rd)}, {name(rs1)}, {name(rs2)}";
      //     behavior: {
      //         signed<32> res = (signed<32>)X[rs1] + (signed<32>)X[rs2];
      //         X[rd] = (signed<64>)res;
      //     }
      // }
      // CHECK-RV64: Pattern for ADDW2: (i64 (sext (i32 (add (i32 GPR:$rs2), (i32 GPR:$rs1)))))
      ADDW2 {
          encoding: 7'b0000000 :: rs2[4:0] :: rs1[4:0] :: 3'b000 :: rd[4:0] :: 7'b0111011;
          assembly: "{name(rd)}, {name(rs1)}, {name(rs2)}";
          behavior: {
              signed<32> res = (signed<32>)X[rs1][31:0] + (signed<32>)X[rs2][31:0];
              X[rd] = (signed<64>)res;
          }
      }
      // CHECK-RV64-NEXT: Pattern for ADDW3: (i64 (sext (i32 (add (i32 GPR:$rs2), (i32 GPR:$rs1)))))
      ADDW3 {
          encoding: 7'b0000000 :: rs2[4:0] :: rs1[4:0] :: 3'b000 :: rd[4:0] :: 7'b0111011;
          assembly: "{name(rd)}, {name(rs1)}, {name(rs2)}";
          behavior: {
              signed<32> res = (signed<32>)XW[rs1] + (signed<32>)XW[rs2];
              X[rd] = (signed<64>)res;
          }
      }

      // CHECK-RV64-NEXT: Pattern for LB: (i64 (sextloadi8 (add GPR:$rs1, (i64 uimm12:$imm))))
      LB {
          encoding: imm[11:0] :: rs1[4:0] :: 3'b000 :: rd[4:0] :: 7'b0000011;
          assembly:"{name(rd)}, {imm}({name(rs1)})";
          behavior: {
              unsigned<XLEN> load_address = X[rs1] + (signed)imm;
              signed<8> res = (signed<8>)MEM8[load_address];
              if((rd) != 0) X[rd] = (unsigned<XLEN>)res;
          }
      }

      // CHECK-RV64-NEXT: Pattern for LH: (i64 (sextloadi16 (add GPR:$rs1, (i64 uimm12:$imm))))
      LH {
          encoding: imm[11:0] :: rs1[4:0] :: 3'b001 :: rd[4:0] :: 7'b0000011;
          assembly:"{name(rd)}, {imm}({name(rs1)})";
          behavior: {
              unsigned<XLEN> load_address = X[rs1] + (signed)imm;
              signed<16> res = (signed<16>)MEM16[load_address];
              if ((rd) != 0) X[rd] = (unsigned<XLEN>)res;
           }
      }

      // CHECK-RV64-NEXT: Pattern for LW: (i64 (sextloadi32 (add GPR:$rs1, (i64 uimm12:$imm))))
      LW {
          encoding: imm[11:0] :: rs1[4:0] :: 3'b010 :: rd[4:0] :: 7'b0000011;
          assembly:"{name(rd)}, {imm}({name(rs1)})";
          behavior: {
              unsigned<XLEN> load_address = X[rs1] + (signed)imm;
              signed<32> res = (signed<32>)MEM32[load_address];
              if ((rd) != 0) X[rd] = (unsigned<XLEN>)res;
          }
      }

      // CHECK-RV64-NEXT: Pattern for LD: (i64 (load (add GPR:$rs1, (i64 uimm12:$imm))))
      LD {
          encoding: imm[11:0] :: rs1[4:0] :: 3'b010 :: rd[4:0] :: 7'b0000011;
          assembly:"{name(rd)}, {imm}({name(rs1)})";
          behavior: {
              unsigned<XLEN> load_address = X[rs1] + (signed)imm;
              signed<64> res = (signed<64>)MEM64[load_address];
              if ((rd) != 0) X[rd] = (unsigned<XLEN>)res;
          }
      }

      // CHECK-RV64-NEXT: Pattern for LBU: (i64 (zextloadi8 (add GPR:$rs1, (i64 uimm12:$imm))))
      LBU {
          encoding: imm[11:0] :: rs1[4:0] :: 3'b100 :: rd[4:0] :: 7'b0000011;
          assembly:"{name(rd)}, {imm}({name(rs1)})";
          behavior: {
              unsigned<XLEN> load_address = X[rs1] + (signed)imm;
              unsigned<8> res = (unsigned<8>)MEM8[load_address];
              if ((rd) != 0) X[rd] = (unsigned<XLEN>)res;
          }
      }

      // CHECK-RV64-NEXT: Pattern for LHU: (i64 (zextloadi16 (add GPR:$rs1, (i64 uimm12:$imm))))
      LHU {
          encoding: imm[11:0] :: rs1[4:0] :: 3'b101 :: rd[4:0] :: 7'b0000011;
          assembly:"{name(rd)}, {imm}({name(rs1)})";
          behavior: {
              unsigned<XLEN> load_address = X[rs1] + (signed)imm;
              unsigned<16> res = (unsigned<16>)MEM16[load_address];
              if((rd) != 0) X[rd] = (unsigned<XLEN>)res;
          }
      }

      // CHECK-RV64-NEXT: Pattern for LWU: (i64 (zextloadi32 (add GPR:$rs1, (i64 uimm12:$imm))))
      LWU {
          encoding: imm[11:0] :: rs1[4:0] :: 3'b010 :: rd[4:0] :: 7'b0000011;
          assembly:"{name(rd)}, {imm}({name(rs1)})";
          behavior: {
              unsigned<XLEN> load_address = X[rs1] + (signed)imm;
              unsigned<32> res = (unsigned<32>)MEM32[load_address];
              if ((rd) != 0) X[rd] = (unsigned<XLEN>)res;
          }
      }

      // SB {
      //     encoding: imm[11:5] :: rs2[4:0] :: rs1[4:0] :: 3'b000 :: imm[4:0] :: 7'b0100011;
      //     assembly:"{name(rs2)}, {imm}({name(rs1)})";
      //     behavior: {
      //         unsigned<XLEN> store_address = X[rs1] + (signed)imm;
      //         MEM8[store_address] = (signed<8>)X[rs2];
      //     }
      // }
      //
      // SH {
      //     encoding: imm[11:5] :: rs2[4:0] :: rs1[4:0] :: 3'b001 :: imm[4:0] :: 7'b0100011;
      //     assembly:"{name(rs2)}, {imm}({name(rs1)})";
      //     behavior: {
      //         unsigned<XLEN> store_address = X[rs1] + (signed)imm;
      //         MEM16[store_address] = (signed<16>)X[rs2];
      //     }
      // }
      //
      // SW {
      //     encoding: imm[11:5] :: rs2[4:0] :: rs1[4:0] :: 3'b010 :: imm[4:0] :: 7'b0100011;
      //     assembly:"{name(rs2)}, {imm}({name(rs1)})";
      //     behavior: {
      //         unsigned<XLEN> store_address = X[rs1] + (signed)imm;
      //         MEM32[store_address] = (signed<32>)X[rs2];
      //     }
      // }
      //
      // CV_LB_ri_inc {
      //     encoding: imm12[11:0] :: rs1[4:0] :: 3'b000 :: rd[4:0] :: 7'b0001011;
      //     // assembly: {"cv.lb", "{name(rd)}, {imm12}({name(rs1)}!)"};
      //     assembly: "{name(rd)}, {imm12}({name(rs1)}!)";
      //     behavior: {
      //         unsigned<XLEN> load_address = X[rs1];
      //         signed<8> res = (signed<8>)MEM8[load_address];
      //         if (rd != 0) X[rd] = (unsigned<XLEN>)res;
      //         X[rs1] += (signed)imm12;
      //     }
      // }

    }

}
